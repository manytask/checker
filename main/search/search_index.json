{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#manytask-checker","title":"Manytask Checker","text":"<p>Checker is a Python cli script to test students' solutions with built-in manytask integration.</p> <ul> <li>production-like - setup for students with gitlab-ci, language-specific testing etc </li> <li>customizable - testing pipeline configuration via yaml files</li> <li>extensible - build-in plugins and ability to write custom plugins<ul> <li>manytask integration with plugin</li> <li>gitlab merge-requests checks with plugin</li> <li>etc</li> </ul> </li> <li>secure - sandbox execution of students' code</li> <li>fast - lightweight script with testing parallelization</li> </ul> <p><code>Requires Python 3.9+</code></p>"},{"location":"#how-it-works","title":"How it works","text":"<p>The <code>checker</code> lib is a part of the <code>manytask</code> ecosystem and extends its functionality. Please refer to the manytask documentation first to understand the drill.</p> <p>tl;dr: Manytask is a web application to manage students', repos, grades and deadlines. It stores grades in google sheet and deadlines on a web page. It also automatically creates gitlab repositories for students as forks from Public Repo with tasks and solution templates.  </p> <p>So you have <code>Public Repo</code> and <code>Students' Repositories</code> and <code>Web App</code> to collect grades and deadlines.  </p> <p>For the checker this setup extends with <code>Private Repo</code> with tasks, tests and solutions and <code>gitlab-ci</code> to run tests in.</p> <p>The <code>checker</code> in a nutshell is a CLI script providing the following functionality:  </p> <ul> <li>grade - to run in a student's repository to test solution against private and public tests and push scores.</li> <li>validate - to run in a private (tutors') repository to validate tasks and deadlines integrity (will run in check automatically).</li> <li>check - to run in a private (tutors') repository to test gold solutions against private and public tests.</li> <li>export - to run in a private (tutors') repository to export tasks, templates and tests to the public repository.</li> </ul> <pre><code>flowchart LR\n    private(Private Repo) --&gt;|checker check| private\n    private --&gt;|checker export| public\n    student([Student's Repo]) --&gt;|checker grade| manytask\n    subgraph gitlab\n        public(Public Repo) -.-&gt;|fork| student\n        public --&gt;|updates| student\n    end\n</code></pre> <p>The flow for tutors looks like:  </p> <ol> <li>Have a manytask ready with empty public repo</li> <li>Create private repo with tasks, tests and solutions</li> <li>Configure checker with yaml files</li> <li>Make docker with your environment and checker installed</li> <li>Write ci file from students to run <code>checker grade</code> on each push/mr</li> <li>Setup private repo ci to run <code>checker check</code> on each push/mr</li> <li>Setup private repo ci to run <code>checker export</code> on each push/mr oor release or regularly or manually</li> <li>Profit!</li> </ol> <p>The flow for students looks like:</p> <ol> <li>Register in manytask and get access to the public repo fork</li> <li>Clone this repo and start working on tasks</li> <li>Update from public repo regularly to get new tasks and tests</li> <li>Push your solution to gitlab where <code>checker grade</code> will run and push scores</li> <li>Profit!</li> </ol> <p>It is a short description, please refer to the checker docs for more details.</p>"},{"location":"#installation","title":"Installation","text":"<p>The <code>checker</code> is available on pypi, so you can install it with pip <pre><code>pip install manytask-checker\n</code></pre></p> <p>Or use pre-built docker image (you can base your image on it) <pre><code>FROM manytask/checker:0.0.1-python3.12\n</code></pre> Please check docker hub for available tags.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Really appreciate any contributions! For guidance on setting up a development environment see the development guide. For styleguide see organization contribution guide.</p>"},{"location":"0_concepts/","title":"Concepts","text":"<p>This page describes the main concepts used in the <code>manytask</code> project - public/private repository, students' repositories, etc.</p>"},{"location":"0_concepts/#manytask","title":"Manytask","text":"<p>This project extends the manytask project, so please refer to its documentation first.  </p> <p>The key <code>manytask</code> concepts are:</p> <ul> <li> <p>Gitlab - a gitlab.com or self-hosted gitlab instance where students' repositories will be created.</p> </li> <li> <p>Manytask/Web App - a web application to manage students', repos, grades and deadlines.     It stores grades in google sheet and display deadlines on a web page.     It also automatically creates gitlab repositories for students as forks from Public Repo with tasks and solution templates.     When used self-hosted gitlab instance, it create gitlab users automatically.</p> </li> <li> <p>Public Repo - a public (only gitlab at the moment) repository with tasks and solution templates.</p> </li> <li> <p>Students' Group - a group where <code>manytask</code> will create repositories for students.</p> </li> <li> <p>Students' Repositories - repositories for students as forks from Public Repo.</p> </li> </ul> <p>Note</p> <p>Manytask do not restrict repository structure in any way, except 1. Students' must have access to the public repository. 2. Students' group should be private, for students not to see each other solutions. 3. <code>.gitlab-ci-students.yml</code> should be present in the public repository root to set up it as <code>external ci file</code> for all students' repositories.</p>"},{"location":"0_concepts/#checker","title":"Checker","text":"<p>Checker is much nore strict in terms of repository structure and overall workflow. However, you can use all or some functions of the checker, which will influence the strictness. In this docs we assume that you use full recommended workflow. </p> <p>First of all, it introduces the following main concepts:</p> <ul> <li> <p>Checker - a CLI script providing the following functionality:</p> <ul> <li>grade - to run in a student's repository to test solution against private and public tests and push scores.</li> <li>validate - to run in a private (tutors') repository to validate tasks and deadlines integrity (will run in check automatically).</li> <li>check - to run in a private (tutors') repository to test gold solutions against private and public tests.</li> <li>export - to run in a private (tutors') repository to export tasks, templates and tests to the public repository.</li> </ul> </li> <li> <p>Docker Env/Testenv - a docker image with your course environment and checker installed.     E.g. cpp compiler, go compiler, python interpreter, additional libraries, etc.     Also, it should contain copy of the private repository with private tests.     It is used to run <code>checker grade</code> in students' repositories and <code>checker check</code> in private repository to have consistent environment and dependencies.     You may use provided <code>checker</code> docker image to base on or create your own from scratch.  </p> </li> <li> <p>Private Repo - a private (tutors) repository with tasks, tests, templates and solutions (and any additional you may need).     This repository have to be private as it contains solutions and optional private tests.      We highly recommend to have testing of gold solution against public and private tests.</p> </li> <li> <p>Private CI - a gitlab ci or github workflow or whatever you use to run </p> <ul> <li><code>checker check</code> on each push/mr in private repository to test gold solution against private and public tests</li> <li><code>checker export</code> on each push/mr/release/regularly to export tasks, templates and tests to the public repository. It should be set up to use the docker image with your environment and checker installed.</li> </ul> </li> <li> <p>Students' CI - a gitlab ci file (only gitlab at the moment) set to run </p> <ul> <li><code>checker grade</code> on each push/mr in students' repositories to test solution against private and public tests and push scores.  </li> <li><code>checker contribute</code> on each mr in public repository to check students' contribution in public tests and test it against gold solution. It should be set up to use the docker image with your environment and checker installed.</li> </ul> </li> <li> <p>Runner - a gitlab-ci (only gitlab at the moment) to run students's tests in it.     As you will have a lot of students' solutions, so it is better to have self-hosted gitlab runner.     It should be connected to the students' group or gitlab self-hosted instance for students' pipelines to run in.  </p> </li> </ul> <p>Also checker introduces the following inner concepts:</p> <ul> <li> <p>Layout - a structure of the private repository (and respectively public repository).      It is described in the Getting Started docs page.</p> </li> <li> <p>Config-s - a yaml files with configuration for checker - <code>.checker.yml</code> and <code>.manytask.yml</code>.     It is described in the Configuration docs page.</p> </li> <li> <p>Pipeline - a yaml-described pipeline in <code>.checker.yml</code> file to run during <code>checker check</code> and <code>checker export</code> commands.      It is described in the Configuration docs page.</p> </li> <li> <p>Plugin - a single stage of the pipeline, have arguments, return exclusion result. In a nutshell, it is a Python class with <code>run</code> method and <code>Args</code> pydantic class.     Checker have some built-in plugins, but you can write your own.     It is described in the Configuration docs page and Plugins docs page.</p> </li> <li> <p>Group - a group of tasks with the same deadlined, can refer as lecture.</p> </li> <li> <p>Task - a task ready to be tested within your environment.  </p> </li> <li> <p>Public Tests/Files - a files to be copied to public repository from private repository, used in testing.</p> </li> <li> <p>Private Tests/Files - a files to NOT be copied to public repository from private repository, but used in testing.</p> </li> <li> <p>Gold Solution - a tutors-written task solution to be tested against public and private tests.     It is used to check tests integrity. Never exposed to students.</p> </li> <li> <p>Template - a solution template files, copied to students' repositories instead of gold solution.</p> </li> <li> <p>Verbose True/False - a flag to set level of verbosity of the checker - private/public.   </p> <ol> <li>When <code>verbose</code> is <code>True</code> - checker will print all logs and results and debug info.  </li> <li>When <code>verbose</code> is <code>False</code> - checker will print only public-friendly outputs - less info, hidden private tests results, etc.  </li> </ol> <p>It is set automatically as True for <code>checker check</code> and False for <code>checker grade</code>/<code>checker check --contribute</code> commands. Plugins have to implement <code>verbose</code> flag.</p> </li> </ul>"},{"location":"0_concepts/#manytask-vs-checker","title":"Manytask vs Checker","text":"<p>Manytask and checker waaay different things.</p> <p>Manytask - web application to host, responsible for the following things:</p> <ol> <li>Get and show deadlines on the web page</li> <li>Get and store students' grades</li> <li>Get and store students' submissions for anti-cheat purposes</li> <li>Create Students' Repositories as forks from Public Repo or as empty repositories</li> <li>(self-hosted gitlab only) Create gitlab users for students</li> </ol> <p>It is language-agnostic and do not care about your course environment and tests. Just create repositories and store grades. Here is the scheme of the manytask workflow: <pre><code>flowchart LR\n    subgraph gitlab\n        public(Public Repo) -.-&gt;|fork| student\n        public --&gt;|updates| student\n        student([Student's Repo])\n    end\n    student --&gt;|push scores| manytask\n    manytask[manytask] -.-&gt;|creates| student\n</code></pre></p> <p>Checker - CLI script to run in CI, responsible for the following things: 1. Test students' solutions against public and private tests 2. Test gold solution against public and private tests 3. Export tasks, templates and tests from private to public repository 4. Validate tasks and deadlines integrity</p> <p>It is language-agnostic, but requires docker with your course environment and pipeline configures in yaml files how to run tests. Here is the scheme of the checker workflow: <pre><code>flowchart LR\n    private(Private Repo) --&gt;|checker check| private\n    private --&gt;|checker export| public\n    student([Student's Repo]) --&gt;|checker grade| manytask\n    subgraph gitlab\n        public(Public Repo) -.-&gt;|fork| student\n        public --&gt;|updates| student\n    end\n    manytask -.-&gt;|creates| student\n</code></pre></p>"},{"location":"1_getting_started/","title":"Getting Started","text":"<p>This page will help you to get started to use <code>checker</code> with your course.  </p> <p>This guide assumes that you have already learned the concepts.</p>"},{"location":"1_getting_started/#starting-point","title":"Starting point","text":"<p>What you already have:</p> <ol> <li>You are a going to create a course with manytask and checker.</li> <li>You have installed (or going to install) manytask.    (So you have empty public repo, private group for students and manytask instance running)</li> </ol> <p>What you need to do:</p> <ol> <li>Create a private repo with specific structure - Layout</li> <li>Create a testing environment - Testing environment</li> <li>Configure your course - Configuration</li> <li>Learn how to test locally - Local testing</li> <li>Learn how to setup Infrastructure - Infrastructure</li> <li>Learn how to set up CI in private and public repos - CI setup</li> </ol> <p>A good starting point is to check out the course-template. This is an example private repo for a python course with tests and tasks. You can fork it and use as a base for your course. </p>"},{"location":"1_getting_started/#layout","title":"Layout","text":"<p>Note</p> <p>tl;dr:  <code>.checker.yml</code> and <code>.manytask.yml</code> in the root of the repo, <code>.task.yml</code> and <code>.group.yml</code> in each tasks and group (can be empty).</p> <p>The private repository layout is crucial for the checker to function correctly.  Each task should be organized into dedicated folders within group directories.  Also, there are 2 config files <code>.course.yml</code> and <code>.manytask.yml</code> that are required for checker to work.</p> <p>Each task location detected by <code>.task.yml</code> file (can be just empty). Each group, if any, detected by <code>.group.yml</code> file (can be empty). </p> <p>Here's a detailed breakdown:</p> <pre><code>group_1/\n    task_1/\n      [solution files].template  # file or folder, if set templates=\"search\" in .checker.yml\n        [some files]\n      [gold solution files]\n      [some private tests]\n      [some public tests]\n      .task.yml  # task config with default parameters overwriting\n    task_2/\n        ...\n    .group.yml  # group config with default parameters overwriting\ngroup_2/\n    task_3/\n        ...\n    task_4/\n        ...\n.checker.yml  # checker config with default parameters and pipelines\n.manytask.yml  # deadlines config with task scores to send to manytask\n</code></pre> <p>Warning</p> <p>Groups and tasks names have to be unique.</p> <p>Warning</p> <p>You have to provide solution templates for each task. Please refer to Templates section for more details.</p> <p>Note</p> <p>By default \".*\" files are considered as private and not copied to public repo, but you can change it in the config.</p> <p>Additionally, you can have any files in like <code>group_1/.lecture</code> folder or <code>tools/my_course_tools</code> folder. Also, probably you want to have <code>.docker</code> file with your test environment and <code>.gitlab-ci-students.yml</code> file to run tests in CI.</p> <p>After Configuration, you can validate your layout with <code>checker validate</code> command.</p>"},{"location":"1_getting_started/#templates","title":"Templates","text":"<p>The aim of the checker to provide as close as possible environment for students and teachers to test solutions. That's why we have templates. Teachers store the gold solution file the same place the student will and template applied only when exporting repo for students.</p> <p>You have to provide solution templates for each task. You have 3 options to setup in <code>.checker.yml</code> (see Configuration for details):</p> <ul> <li> <p><code>templates: \"search\"</code> - checker will search for files or folders with <code>.template</code> extension in the task directory and use them as templates.     Original file/folder will be deleted and replaced with a template (<code>.template</code> extension will be removed).     For example, if you have <code>task_1/solution.py.template</code> file, checker will use it as a template to replace gold solution <code>task_1/solution.py</code> file.     This is the default option.</p> <p>If you have an empty file/folder with <code>.template</code> extension, checker will just delete original file/folder.</p> </li> <li> <p><code>templates: \"create\"</code> - checker will search for the template comments in your gold solution and will delete everything except the template.     For example, if you have <code>task_1/solution.py</code> file with a pair of comments <code>SOLUTION BEGIN</code> and <code>SOLUTION END</code>:     <pre><code>a = 1\n# SOLUTION BEGIN\nprint(a)\n# SOLUTION END\nb = a + 1\nb += 1\n# SOLUTION BEGIN\nprint(b)\n# SOLUTION END\n</code></pre>     When exporting to public checker will replace it with <code>TODO: Your solution</code> in NOT-greedy way:     <pre><code>a = 1\n# TODO: Your solution\nb = a + 1\nb += 1\n# TODO: Your solution\n</code></pre>     Note: You can have multiple templates in one file.     Note2: If you write both <code>SOLUTION BEGIN</code> and <code>SOLUTION END</code> as comments, resulting <code>TODO: Your solution</code> will be a comment as well.</p> <p>If after templating the file is empty, checker will delete it.</p> </li> <li> <p><code>templates: \"search_or_create\" - checker will try to use</code>search<code>and if it fails, it will use</code>create`.    You CAN NOT have 2 types of templating in the same task, but can use any of them in different tasks.  </p> </li> </ul> <p>Warning</p> <p>Each task have to have at least one template file or folder.</p>"},{"location":"1_getting_started/#testing-environment","title":"Testing environment","text":"<p>Note</p> <p>tl;dr:  You somehow need to run checker in your CI. Build docker with <code>checker</code> and your course-specific pkgs.</p> <p>To run tests you need to have a docker testing environment that includes your course's specific environment and the pre-installed checker. Here\u2019s how you can prepare and utilize it: </p> <p>You have 2 options:</p> <ol> <li> <p>Build you docker image from scratch and install checker there. This way you have full control and can minimize the size of the image as much as you like.     The <code>checker</code> is available on pypi, so you can install it with pip     <pre><code>pip install manytask-checker\n</code></pre></p> </li> <li> <p>Use checker pre-built base-docker image to base on. This way you can save some time and effort and just add your course-specific environment to the image.</p> <pre><code>FROM manytask/checker:0.0.1-python3.8\n...\n</code></pre> </li> </ol>"},{"location":"1_getting_started/#configuration","title":"Configuration","text":"<p>The configuration of the checker and Manytask requires setting up 2 main files: <code>.course.yml</code> and <code>.manytask.yml</code> and custom <code>.task.yml</code> files for each task when needed.  Here is the short overview of the configuration files:</p> <ul> <li> <p>Checker Configuration (<code>.checker.yml</code>):     This file specifies the default parameters for the checker script and defines the pipelines for task checking and exporting.</p> </li> <li> <p>Deadlines Configuration (<code>.manytask.yml</code>):     This file outlines the deadlines for each group, task max score and etc.     In the checker it is used a) to validate deadlines integrity and b) to send scores to manytask.</p> </li> <li> <p>Group Configuration (<code>.group.yml</code>):     Optional file located in group directory, this file allows for task-specific settings. It can override default parameters, private/public files and pipelines set in .checker.yml for individual groups.     (apply to any subdirectory)</p> </li> <li> <p>Task Configuration (<code>.task.yml</code>):     Optional file located in task directory, this file allows for task-specific settings. It can override default parameters, private/public files and pipelines set in .checker.yml for individual tasks.</p> </li> </ul> <p>For the full guide on configuration, see the Configuration docs page.</p>"},{"location":"1_getting_started/#local-testing","title":"Local testing","text":"<p>For local testing of private repo you have 2 options:</p> <ol> <li> <p>Install checker on your machine     <pre><code># create virtualenv\npython -m venv .venv\nsource .venv/bin/activate\n# install checker\n(.venv) pip install manytask-checker\n</code></pre>     And use it as a cli application from inside your private repo     <pre><code>(.venv) checker check --task hello-world\n(.venv) checker check --group lecture-1\n(.venv) checker check\n</code></pre></p> </li> <li> <p>Use test environment docker you made before in interactive mode     <pre><code># run docker in interactive mode mounting your repo as /course\ndocker run -it --rm -v $(pwd):/course -w /course manytask/checker:0.0.1-python3.8 bash\n</code></pre>     And use it as a cli application from inside your private repo     <pre><code># inside docker\n&gt; checker check --task hello-world\n&gt; checker check --group lecture-1\n&gt; checker check\n</code></pre></p> </li> </ol> <p>Note</p> <p>#1 is faster and easier to debug, it is ok for local testing, #2 ensure that your tests will run in the same environment as in CI.</p>"},{"location":"1_getting_started/#infrastructure","title":"Infrastructure","text":"<p>Note</p> <p>tl;dr:  You need to set up gitlab, gitlab runner, docker registry, manytask instance and prepare gitlab token.</p> <p>Setting up the infrastructure for Manytask and checker involves configuring the runtime environment:</p> <p>Manytask requite the following:</p> <ol> <li> <p>(optional) Self-hosted GitLab instance - storing public repo and students' repos.      Manytask and checker can work with gitlab.com, but you can use self-hosted gitlab instance for better control, privacy and performance.     Please refer to gitlab docs for installation instructions.</p> </li> <li> <p>Manytask instance - web application managing students' grades (in google sheet) and deadlines (web page).     Please refer to manytask docs.</p> </li> </ol> <p>So the checker extends it with the following:</p> <ol> <li> <p>Gitlab Runner - place where students' solutions will be tested.     You definitely need it as the students will consume your free CI minutes extremely fast.       Please refer to gitlab runners docs for installation instructions.     Add this runner as a student group runner to your course group or as a shared runner to your gitlab instance.</p> </li> <li> <p>(optional) GitHub Runner - if you are using GitHub for your private repo, you may need to set up GitHub runner.     Please refer to github runners docs for installation instructions.     However, at the moment, GitHub provides 2000 CI minutes for org, so it may be to start with.</p> </li> <li> <p>(optional) Private Docker Registry - to store testing environment docker image (it contains private tests).       You can use anything you like, but we recommend to use gitlab registry as it is already integrated with gitlab.</p> </li> <li> <p>Gitlab token - with public repos access to export files to the public repo.     You need to add it as a secret to your private repo and use it in CI. Also if you want to use in it pipelines in students' repos, you need to add it as a secret to your course group.     If you have self-hosted gitlab instance or premium account, you can create service account for the course group using this guide.     Otherwise, you have to create a separate account, grant access to the course group and use its personal access token. </p> </li> </ol> <p>Note</p> <p>For an automated setup, refer to the manytask/infrastructure repository with ansible playbooks.   These playbooks provide a stable and tested setup for the self-hosted gitlab instance, manytask instance and gitlab runners (configuration included).</p>"},{"location":"1_getting_started/#ci-set-up","title":"CI set up","text":"<p>Note</p> <p>tl;dr:  Setup private and public CI to run tests. </p> <p>Configuring Continuous Integration (CI) is essential for automating the testing and deployment processes. Here's how to set it up for both private and public repositories.  </p> <ol> <li> <p>Private Repo     You can refer to the course-template for an example of a private repo with CI set up.</p> <ul> <li> <p>Private repo on GitHub (recommended way)   If your private repo is on GitHub, you can use GitHub Actions and Reusable Workflows provided by us to set up CI in a few clicks.</p> </li> <li> <p>Private repo on GitLab   If your private repo is on GitLab, you can use GitLab CI, no pre-configured workflows are available at the moment.</p> </li> </ul> <p>You need to set up the following CI jobs:</p> <ol> <li>on each push/mr/release - build testing environment docker image and keep as artifact to run tests in.  </li> <li>on each push/mr - run <code>checker check</code> inside docker image to test gold solution against private and public tests.   </li> <li>on each push/release - run <code>checker export</code> inside docker image to export to the public repository (requires gitlab token).  </li> <li>on each push/release - call manytask api to update deadlines (requires manytask push token).  </li> <li>on each push/release - build and publish testing environment docker image to the private docker registry (requires gitlab token).</li> </ol> <p>Note</p> <p>Don't forget to add MANYTASK_TOKEN and GITLAB_TOKEN as protected secrets to your private repo. </p> </li> <li> <p>Public Repo     Checker will push to this repo automatically and no pipelines to run, so nothing to configure directly here.     However the public repo should have <code>.gitlab-ci-students.yml</code> file in the root to set up it as <code>external ci file</code> for all students' repositories.     This file should contain 2 jobs, both running inside test environment docker image:</p> <ol> <li>on each push/mr - run <code>checker grade</code> to test solution against private and public tests and push scores to manytask (requires manytask push token).</li> <li>on each mr in public repo - run <code>checker check --contribute</code> to test contributed public tests against gold solution. </li> </ol> </li> <li> <p>Students' Group     Students' repos will use groups or shared runners from this group, so make sure that they are enabled.</p> <p>Note</p> <p>Don't forget to add MANYTASK_TOKEN and GITLAB_TOKEN (optional) as protected secrets to your group. </p> </li> </ol>"},{"location":"2_configuration/","title":"Configuration","text":"<p>This page describes how to configure checker with <code>.checker.yml</code>, <code>.manytask.yml</code> and <code>.group.yml</code>/<code>.task.yml</code> files.</p> <p>You can refer to the course-template repository for examples of configuration files.</p>"},{"location":"2_configuration/#checkeryml","title":"<code>.checker.yml</code>","text":"<p>This file describes how the checker will operate - how to export files, how to run pipelines and so on.</p> <p>TBA</p> <p>No json schema available yet, but you can refer to the checker.configs.checker.CheckerConfig in checker repository. Or course-template repository.</p> <p>Warning</p> <p>The structure section requires glob patterns to be valid and will apply the same patterns recursively to all subdirectories. The moment it faces <code>.task.yml</code> file, it will stop and use the parameters from this file recursively. No <code>**</code> patterns are allowed.</p> <p>Please refer to the plugins and pipelines sections for more information on how to configure pipelines.</p>"},{"location":"2_configuration/#example","title":"Example","text":"<p>The simple <code>.checker.yml</code> file is:</p> <pre><code># .checker.yml\nversion: 1\n\n# can be overwritten in .task.yml for individual tasks\nstructure:\n  # ignore patterns: exclude from export, overwrite during testing\n  ignore_patterns: [\".git\", \".idea\", \".vscode\", \"__pycache__\", \".venv\", \".*_cache\", \"*.pyc\"]\n  # public patterns: include in export, overwrite during testing\n  public_patterns: [\"*\", \".gitlab-ci-students.yml\", \".gitignore\"]\n  # private patterns: exclude from export, overwrite during testing\n  private_patterns: [\".*\"]\n\n# default values for all tasks, can be overwritten in .task.yml params:\ndefault_parameters:\n  run_testing: true\n  timeout: 10  # in seconds\n\n# settings for export command, uses .manytask.yml and `params` and each task params (in .task.yml)\nexport:\n  destination: https://gitlab.manytask.org/test/public-test-repo\n\n# settings for Tester, uses .checker.yml and `params` and each task params (in .task.yml)\ntesting:\n  changes_detection: branch_name  # branch_name, commit_message, last_commit_changes\n  search_plugins: [\"tools/plugins\"]\n\n  # run once per repo\n  global_pipeline:\n    - ...\n  # run once per task\n  tasks_pipeline:\n    - ...\n    - ...\n  # will run once per task only if task_pipeline NOT failed\n  report_pipeline:\n    - ...\n</code></pre> <p>Note</p> <p><code>changes_detection</code> parameter select how to detect changes in the repo during testing (<code>checker grade</code> command). It can be one of the following: * <code>branch_name</code> - check if the branch name == task/group name (select only one task/group) * <code>commit_message</code> - check if the commit message contains task/group name (can select multiple tasks/groups) * <code>last_commit_changes</code> - check if the last commit contains changes in the task folder (can select multiple tasks) * <code>files</code> - (NOT IMPLEMENTED) check actual file difference between current state and the previous commit (can select multiple tasks)</p>"},{"location":"2_configuration/#manytaskyml","title":"<code>.manytask.yml</code>","text":"<p>This file describes deadlines for tasks. It is used by <code>checker export</code> command to export only tasks that are started. Additionally, it is used by <code>checker validate</code> to ensure integrity of the deadlines and local files.</p> <p>No json schema available yet, but you can refer to the checker.configs.deadlines.DeadlinesConfig in checker repository. Or course-template repository.</p>"},{"location":"2_configuration/#example_1","title":"Example","text":"<p>The simple <code>.manytask.yml</code> file is: <pre><code># .manytask.yml\nversion: 1\n\nsettings:\n  timezone: Europe/Moscow\n\n  deadlines: hard  # hard/interpolate\n  max_submissions: 10  # optional\n  submission_penalty: 0.1  # optional\n\n  task_url: https://example.com/$GROUP_NAME/$TASK_NAME  # optional\n\nschedule:\n  - group: 1.FirstGroup\n    enabled: true\n    start: 2020-01-01 18:00:00\n    steps:\n      0.5: 7d\n    end: 13d 03:00:00\n    tasks:\n      - task: hello_world\n        score: 10\n        bonus: 0\n        special: 1\n      - task: sum_a_b\n        score: 5\n        bonus: 5\n        special: 0\n      - task: disabled_task\n        enabled: false\n        score: 5\n\n  - group: 2.SecondGroup\n    start: 2020-02-01 18:00:00\n    steps:\n      0.9: 2020-02-08 18:00:00\n      0.1: 14d\n    tasks:\n      - task: factorial\n        score: 20\n\n  - group: 3.ThirdGroup\n    start: 2020-03-01 18:00:00\n    tasks:\n      - task: palindrome\n        score: 0\n        special: 2\n        url: https://example.com\n\n  - group: 4.FourthGroup\n    enabled: false\n    start: 2020-04-01 18:00:00\n    tasks: []\n</code></pre></p>"},{"location":"2_configuration/#groupymltaskyml","title":"<code>.group.yml</code>/<code>.task.yml</code>","text":"<p>This config files override parameters for the current folder and all subfolders. When some field is not defined (e.g. only version present) the default parameter from the main config or from the folder above applied.</p> <p>No json schema available yet, but you can refer to the checker.configs.task.TaskConfig in checker repository. Or course-template repository.</p>"},{"location":"2_configuration/#example_2","title":"Example","text":"<pre><code># .task.yml\nversion: 1\n\nstructure:  # optional\n  ignore_patterns: [\"*.pyc\"]\n  public_patterns: [\"custom_public_file.txt\"]\n  private_patterns: [\".*\", \"custom_private_tests.py\"]\n\nparameters:  # optional\n  run_testing: true\n  timeout: 10  # in seconds\n\ntask_pipeline:  # optional\n  ...\n\nreport_pipeline:  # optional\n  ...\n</code></pre>"},{"location":"3_plugins/","title":"Plugins","text":"<p>This page describes how to use and write plugins for checker pipelines.</p> <p>You can refer to the course-template repository for examples of plugins usage and custom plugins development.</p>"},{"location":"3_plugins/#what-is-the-plugin","title":"What is the Plugin","text":"<pre><code>  tasks_pipeline:\n    - name: \"Check forbidden regexps\"\n      fail: fast  # fast, after_all, never\n      run: \"check_regexps\"\n      args:\n        origin: \"${{ global.temp_dir }}/${{ task.task_sub_path }}\"\n        patterns: [\"**/*.py\"]\n        regexps: [\"exit(0)\"]\n\n    - name: \"Run linter\"\n      run_if: ${{ parameters.run_linting }}\n      fail: after_all  # fast, after_all, never\n      run: \"run_script\"\n      args:\n        origin: ${{ global.temp_dir }}\n        script: \"python -m ruff --config=pyproject.toml ${{ task.task_sub_path }}\"\n</code></pre> <p>Plugin is a single stage of the pipeline, have arguments, return exclusion result.  In a nutshell, it is a Python class overriding abstract class <code>checker.plugins.PluginABC</code>:</p> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for plugins. :ivar name: str plugin name, searchable by this name</p> Source code in <code>checker/plugins/base.py</code> <pre><code>class PluginABC(ABC):\n    \"\"\"Abstract base class for plugins.\n    :ivar name: str plugin name, searchable by this name\n    \"\"\"\n\n    name: str\n\n    class Args(BaseModel):\n        \"\"\"Base class for plugin arguments.\n        You have to subclass this class in your plugin.\n        \"\"\"\n\n        pass\n\n    def run(self, args: dict[str, Any], *, verbose: bool = False) -&gt; PluginOutput:\n        \"\"\"Run the plugin.\n        :param args: dict plugin arguments to pass to subclass Args\n        :param verbose: if True should print teachers debug info, if False student mode\n        :raises BadConfig: if plugin arguments are invalid\n        :raises ExecutionFailedError: if plugin failed\n        :return: PluginOutput with stdout/stderr and percentage\n        \"\"\"\n        args_obj = self.Args(**args)\n\n        return self._run(args_obj, verbose=verbose)\n\n    @classmethod\n    def validate(cls, args: dict[str, Any]) -&gt; None:\n        \"\"\"Validate the plugin arguments.\n        :param args: dict plugin arguments to pass to subclass Args\n        :raises BadConfig: if plugin arguments are invalid\n        :raises BadStructure: if _run method is not implemented\n        \"\"\"\n        try:\n            cls.Args(**args)\n        except ValidationError as e:\n            raise BadConfig(f\"Plugin {cls.name} arguments validation error:\\n{e}\")\n\n        if not hasattr(cls, \"_run\"):\n            raise BadStructure(f\"Plugin {cls.name} does not implement _run method\")\n\n    @abstractmethod\n    def _run(self, args: Args, *, verbose: bool = False) -&gt; PluginOutput:\n        \"\"\"Actual run the plugin.\n        You have to implement this method in your plugin.\n        In case of failure, raise ExecutionFailedError with an error message and output.\n        :param args: plugin arguments, see Args subclass\n        :param verbose: if True should print teachers debug info, if False student mode\n        :return: PluginOutput with stdout/stderr and percentage\n        :raises ExecutionFailedError: if plugin failed\n        \"\"\"\n        pass\n</code></pre> <p>Note that each plugin should override <code>checker.plugins.PluginABC.Args</code> class to provide arguments validation. Otherwise, empty arguments will be passed to <code>run</code> method.</p> <p>               Bases: <code>BaseModel</code></p> <p>Base class for plugin arguments. You have to subclass this class in your plugin.</p> Source code in <code>checker/plugins/base.py</code> <pre><code>class Args(BaseModel):\n    \"\"\"Base class for plugin arguments.\n    You have to subclass this class in your plugin.\n    \"\"\"\n\n    pass\n</code></pre> <p>Each plugin output <code>checker.plugins.PluginOutput</code> class when executed successfully. </p> <p>Plugin output dataclass. :ivar output: str plugin output :ivar percentage: float plugin percentage</p> Source code in <code>checker/plugins/base.py</code> <pre><code>@dataclass\nclass PluginOutput:\n    \"\"\"Plugin output dataclass.\n    :ivar output: str plugin output\n    :ivar percentage: float plugin percentage\n    \"\"\"\n\n    output: str\n    percentage: float = 1.0\n</code></pre> <p>In case of error, <code>checker.exceptions.PluginExecutionFailed</code> have to be raised.</p> <p>               Bases: <code>TestingError</code></p> <p>Exception raised when plugin execution failed</p> Source code in <code>checker/exceptions.py</code> <pre><code>@dataclass\nclass PluginExecutionFailed(TestingError):\n    \"\"\"Exception raised when plugin execution failed\"\"\"\n\n    message: str = \"\"\n    output: str | None = None\n    percentage: float = 0.0\n</code></pre> <p>Note</p> <p>Base Plugin class will handle all ValidationErrors of Args and raise error by itself. So try to move all arguments validation to <code>Args</code> class in <code>pydantic</code> way.</p>"},{"location":"3_plugins/#checker.plugins.base.PluginABC.Args","title":"<code>Args</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for plugin arguments. You have to subclass this class in your plugin.</p> Source code in <code>checker/plugins/base.py</code> <pre><code>class Args(BaseModel):\n    \"\"\"Base class for plugin arguments.\n    You have to subclass this class in your plugin.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"3_plugins/#checker.plugins.base.PluginABC.run","title":"<code>run(args, *, verbose=False)</code>","text":"<p>Run the plugin. :param args: dict plugin arguments to pass to subclass Args :param verbose: if True should print teachers debug info, if False student mode :raises BadConfig: if plugin arguments are invalid :raises ExecutionFailedError: if plugin failed :return: PluginOutput with stdout/stderr and percentage</p> Source code in <code>checker/plugins/base.py</code> <pre><code>def run(self, args: dict[str, Any], *, verbose: bool = False) -&gt; PluginOutput:\n    \"\"\"Run the plugin.\n    :param args: dict plugin arguments to pass to subclass Args\n    :param verbose: if True should print teachers debug info, if False student mode\n    :raises BadConfig: if plugin arguments are invalid\n    :raises ExecutionFailedError: if plugin failed\n    :return: PluginOutput with stdout/stderr and percentage\n    \"\"\"\n    args_obj = self.Args(**args)\n\n    return self._run(args_obj, verbose=verbose)\n</code></pre>"},{"location":"3_plugins/#checker.plugins.base.PluginABC.validate","title":"<code>validate(args)</code>  <code>classmethod</code>","text":"<p>Validate the plugin arguments. :param args: dict plugin arguments to pass to subclass Args :raises BadConfig: if plugin arguments are invalid :raises BadStructure: if _run method is not implemented</p> Source code in <code>checker/plugins/base.py</code> <pre><code>@classmethod\ndef validate(cls, args: dict[str, Any]) -&gt; None:\n    \"\"\"Validate the plugin arguments.\n    :param args: dict plugin arguments to pass to subclass Args\n    :raises BadConfig: if plugin arguments are invalid\n    :raises BadStructure: if _run method is not implemented\n    \"\"\"\n    try:\n        cls.Args(**args)\n    except ValidationError as e:\n        raise BadConfig(f\"Plugin {cls.name} arguments validation error:\\n{e}\")\n\n    if not hasattr(cls, \"_run\"):\n        raise BadStructure(f\"Plugin {cls.name} does not implement _run method\")\n</code></pre>"},{"location":"3_plugins/#how-to-use-plugins","title":"How to use plugins","text":"<p>Plugins are used in the pipelines described in <code>.checker.yml</code> file. When running a pipeline the checker will validate plugin arguments and run it.</p> <p>The following plugins are available out of the box, here is the list with their arguments:</p> <ul> <li> <p><code>run_script</code> - execute any script with given arguments  </p> <p>               Bases: <code>Args</code></p> Source code in <code>checker/plugins/scripts.py</code> <pre><code>class Args(PluginABC.Args):\n    origin: str\n    script: Union[str, list[str]]  # as pydantic does not support | in older python versions\n    timeout: Union[float, None] = None  # as pydantic does not support | in older python versions\n    env_whitelist: Optional[list[str]] = None\n</code></pre> </li> <li> <p><code>safe_run_script</code> - execute script withing firejail sandbox </p> <p>               Bases: <code>Args</code></p> Source code in <code>checker/plugins/firejail.py</code> <pre><code>class Args(PluginABC.Args):\n    origin: str\n    script: Union[str, list[str]]  # as pydantic does not support | in older python versions\n    timeout: Union[float, None] = None  # as pydantic does not support | in older python versions\n\n    env_whitelist: list[str] = list()\n    paths_whitelist: list[str] = list()\n    lock_network: bool = True\n    allow_fallback: bool = False\n</code></pre> </li> <li> <p><code>check_regexps</code> - error if given regexps are found in the files  </p> <p>               Bases: <code>Args</code></p> Source code in <code>checker/plugins/regex.py</code> <pre><code>class Args(PluginABC.Args):\n    origin: str\n    patterns: list[str]\n    regexps: list[str]\n</code></pre> </li> <li> <p><code>aggregate</code> - aggregate results of other plugins (e.g. sum/mean/mul scores)  </p> <p>               Bases: <code>Args</code></p> Source code in <code>checker/plugins/aggregate.py</code> <pre><code>class Args(PluginABC.Args):\n    scores: list[float]\n    weights: Union[list[float], None] = None  # as pydantic does not support | in older python versions\n    strategy: Literal[\"mean\", \"sum\", \"min\", \"max\", \"product\"] = \"mean\"\n</code></pre> </li> <li> <p><code>report_score_manytask</code> - report score to manytask  </p> <p>               Bases: <code>Args</code></p> Source code in <code>checker/plugins/manytask.py</code> <pre><code>class Args(PluginABC.Args):\n    origin: Optional[str] = None  # as pydantic does not support | in older python versions\n    patterns: list[str] = [\"*\"]\n    username: str\n    task_name: str\n    score: float  # TODO: validate score is in [0, 1] (bonus score is higher than 1)\n    report_url: AnyUrl\n    report_token: str\n    check_deadline: bool\n    send_time: datetime = datetime.now().astimezone()\n</code></pre> </li> <li> <p><code>check_gitlab_merge_request</code> - [WIP] check gitlab MR is valid (no conflicts, no extra files, has label etc.)</p> <p>               Bases: <code>Args</code></p> Source code in <code>checker/plugins/gitlab.py</code> <pre><code>class Args(PluginABC.Args):\n    token: str\n    task_dir: str\n    repo_url: AnyUrl\n    requre_approval: bool = False\n    search_for_score: bool = False\n</code></pre> </li> <li> <p><code>collect_score_gitlab_merge_request</code> - [WIP] search for score by tutor in gitlab MR comment    </p> <p>               Bases: <code>Args</code></p> Source code in <code>checker/plugins/gitlab.py</code> <pre><code>class Args(PluginABC.Args):\n    token: str\n    task_dir: str\n    repo_url: AnyUrl\n    requre_approval: bool = False\n    search_for_score: bool = False\n</code></pre> </li> </ul>"},{"location":"3_plugins/#how-to-write-a-custom-plugin","title":"How to write a custom plugin","text":"<p>To write a custom plugin you need to create a class inheriting from <code>checker.plugins.PluginABC</code> and override <code>_run</code> method, <code>Args</code> inner class and set <code>name</code> class attribute.</p> <pre><code>from random import randint\nfrom checker.plugins import PluginABC, PluginOutput\nfrom checker.exceptions import PluginExecutionFailed\nfrom pydantic import AnyUrl\n\nclass PrintUrlPlugin(PluginABC):\n    \"\"\"Plugin to print url\"\"\"\n\n    name = \"print_url\"\n\n    class Args(PluginABC.Args):\n        url: AnyUrl\n\n    def _run(self, args: Args, *, verbose: bool = False) -&gt; PluginOutput:\n        if randint(0, 1):\n            if verbose:\n                raise PluginExecutionFailed(\"Verbose error, we got randint=1\")\n            else:\n                raise PluginExecutionFailed(\"Random error\")\n\n        return PluginOutput(\n            output=f\"Url is {args.url}\",\n            percentage=1.0,  # optional, default 1.0 on success\n        )\n</code></pre> <p>Important</p> <p>The Plugin must implement <code>verbose</code> functionality! If <code>verbose</code> is <code>True</code> the plugin should provide all info and possible debug info. If <code>verbose</code> is <code>False</code> the plugin should provide only public-friendly info, e.g. excluding private test output.</p> <p>Note</p> <p>It is a nice practice to write a small tests for your custom plugins to be sure that it works as expected.</p>"},{"location":"4_pipelines/","title":"Pipelines","text":"<p>This is the most important part of the checker. Pipelines are used to actually check and grade the solution.  Each pipeline is a sequence of plugins. Each plugin (pipeline stage) have arguments, run_if condition and return exclusion result. </p> <p>Please refer to the plugins configuration for more details on pre-defined and custom plugins.</p>"},{"location":"4_pipelines/#3-pipeline-types","title":"3 pipeline types","text":"<p>There are 3 types of pipelines you need to define in <code>.checker.yml</code> file: * <code>global_pipeline</code> - pipeline to be executed once for all checker repository.     You can place here any general compilation, installation, etc. * <code>task_pipeline</code> - pipeline to be executed for each task.     You can place here any task-specific compilation, installation, etc.     For example, you run <code>pytest</code> by default, but for some tasks you want to have MR checked first.     (can be re-defined in <code>.task.yml</code> file) * <code>report_pipeline</code> - pipeline to be executed for each task after all tests are passed (not failed).     You can place here any task-specific score reporting, etc.     For example, you can report the score to the Manytask platform, but for some tasks you want to have MR checked first.     (can be re-defined in <code>.task.yml</code> file)</p> <pre><code># .checker.yml\n...\ntesting:\n  # once\n  global_pipeline:\n    - name: \"Install requirements\"\n      run: \"run_script\"\n      args:\n        ...\n  # for each task\n  task_pipeline:\n    - name: \"Run pytest\"\n      run: \"pytest\"\n      args:\n        ...\n  # for each task after task_pipeline is passed\n  report_pipeline:\n    - name: \"Report Score Manytask\"\n      run: \"report_score_manytask\"\n      args: \n        ...\n...\n</code></pre>"},{"location":"4_pipelines/#single-pipeline-stage","title":"Single pipeline stage","text":"<p>Each pipeline stage is a plugin called with arguments. Here is the example of a single pipeline stage: <pre><code>  - name: \"Check forbidden regexps\"  \n    fail: fast\n    run: \"check_regexps\"\n    run_if: true\n    register_output: \"forbidden_regexps\"\n    args:\n      origin: \"/tmp/origin\"\n      patterns: [\"**/*.py\"]\n      regexps: [\"exit(0)\"]\n</code></pre></p> <ul> <li><code>name</code>: Human-readable name of the pipeline stage to be shown in the logs.  </li> <li><code>fail</code>: Defines how to handle the failure of this pipeline stage.  <ul> <li><code>fast</code> - (default) fail fast, stop the pipeline and fail the task immediately.  </li> <li><code>after_all</code> - fail after all pipeline stages are executed.  </li> <li><code>never</code> - ignore the failure of this pipeline stage.</li> </ul> </li> <li><code>run</code>: key name of the plugin to be executed. Will be searched within pre-defined and custom plugins.</li> <li><code>run_if</code>: condition to run this pipeline stage. Cast to bool, <code>true</code> by default.</li> <li><code>register_output</code>: name of the output to be registered in <code>outputs</code> variable. The <code>PipelineStageResult</code> object will be stored in <code>outputs</code> dict with this name.</li> <li><code>args</code>: arguments to be passed to the plugin.     Arguments are validated by <code>pydantic</code> library as defined by each individual plugin.  </li> </ul>"},{"location":"4_pipelines/#templating-in-tester-pipelines","title":"Templating in Tester Pipelines","text":"<p>You can use jinja2 templating in <code>.checker.yml</code> file pipeline arguments and <code>run_if</code> conditions. They can be used with <code>${{ ... }}</code> syntax, expression within this brackets will be evaluated before plugin execution. For example: <pre><code>  report_pipeline:\n    - name: \"Report Score Manytask\"\n      run: \"report_score_manytask\"\n      args:\n        origin: \"${{ global.temp_dir }}/${{ task.task_sub_path }}\"\n        patterns: [\"**/*.py\"]\n        username: ${{ global.username }}\n        task_name: ${{ task.task_name }}\n        score: ${{ outputs.test_output.percentage }}\n</code></pre></p> <p>The available variables are:</p> <ul> <li> <p><code>global</code> - global parameters  </p> <p>Base variables passed in pipeline stages.</p> Source code in <code>checker/tester.py</code> <pre><code>@dataclass\nclass GlobalPipelineVariables:\n    \"\"\"Base variables passed in pipeline stages.\"\"\"\n\n    ref_dir: str\n    repo_dir: str\n    temp_dir: str\n    task_names: list[str]\n    task_sub_paths: list[str]\n</code></pre> </li> <li> <p><code>task</code> - task parameters  </p> <p>Variables passed in pipeline stages for each task.</p> Source code in <code>checker/tester.py</code> <pre><code>@dataclass\nclass TaskPipelineVariables:\n    \"\"\"Variables passed in pipeline stages for each task.\"\"\"\n\n    task_name: str\n    task_sub_path: str\n</code></pre> </li> <li> <p><code>parameters</code> - default parameters</p> <p>               Bases: <code>RootModel[dict[str, TParamType]]</code></p> Source code in <code>checker/configs/checker.py</code> <pre><code>class CheckerParametersConfig(RootModel[dict[str, TParamType]]):\n    root: dict[str, TParamType]\n\n    def __getitem__(self, item: str) -&gt; TParamType:\n        return self.root[item]\n\n    def __contains__(self, item: str) -&gt; bool:\n        return item in self.root\n\n    @property\n    def __dict__(self) -&gt; dict[str, TParamType]:\n        return self.root\n\n    @__dict__.setter\n    def __dict__(self, value: dict[str, TParamType]) -&gt; None:\n        self.root = value\n</code></pre> </li> <li> <p><code>env</code> - environment variables dict in the moment of running checker</p> </li> <li> <p><code>outputs</code> - outputs of previous pipeline step if <code>register_output</code> is set, dict of string to <code>checker.plugins.PluginOutput</code> objects  </p> <p>Result of a single pipeline stage. :param name: name of the stage :param failed: if True, stage failed :param skipped: if True, stage was skipped :param percentage: optional percentage of points earned :param elapsed_time: optional elapsed time in seconds :param output: output of the stage</p> Source code in <code>checker/pipeline.py</code> <pre><code>@dataclass\nclass PipelineStageResult:\n    \"\"\"Result of a single pipeline stage.\n    :param name: name of the stage\n    :param failed: if True, stage failed\n    :param skipped: if True, stage was skipped\n    :param percentage: optional percentage of points earned\n    :param elapsed_time: optional elapsed time in seconds\n    :param output: output of the stage\n    \"\"\"\n\n    name: str\n    failed: bool\n    skipped: bool\n    percentage: float | None = None\n    elapsed_time: float | None = None\n    output: str = \"\"\n\n    def __str__(self) -&gt; str:  # pragma: no cover\n        return (\n            f\"PipelineStageResult: failed={int(self.failed)}, \"\n            f\"skipped={int(self.skipped)}, percentage={self.percentage or 1.0:.2f}, name='{self.name}'\"\n        )\n</code></pre> </li> </ul>"},{"location":"4_pipelines/#pipeline-stage-result","title":"Pipeline stage result","text":"<p>Each stage can optionally register its output in <code>outputs</code> context to be used by the next stages. e.g. register percentage of passed tests to be used in the next stage to report the score.</p> <p>Each pipeline processes internally as <code>PipelineStageResult</code> object. It contains the following fields:</p> <p>Result of a single pipeline stage. :param name: name of the stage :param failed: if True, stage failed :param skipped: if True, stage was skipped :param percentage: optional percentage of points earned :param elapsed_time: optional elapsed time in seconds :param output: output of the stage</p> Source code in <code>checker/pipeline.py</code> <pre><code>@dataclass\nclass PipelineStageResult:\n    \"\"\"Result of a single pipeline stage.\n    :param name: name of the stage\n    :param failed: if True, stage failed\n    :param skipped: if True, stage was skipped\n    :param percentage: optional percentage of points earned\n    :param elapsed_time: optional elapsed time in seconds\n    :param output: output of the stage\n    \"\"\"\n\n    name: str\n    failed: bool\n    skipped: bool\n    percentage: float | None = None\n    elapsed_time: float | None = None\n    output: str = \"\"\n\n    def __str__(self) -&gt; str:  # pragma: no cover\n        return (\n            f\"PipelineStageResult: failed={int(self.failed)}, \"\n            f\"skipped={int(self.skipped)}, percentage={self.percentage or 1.0:.2f}, name='{self.name}'\"\n        )\n</code></pre> <p>And can be accessed in the next pipeline stages using templating syntax <code>${{ outputs.&lt;registered-name&gt;.&lt;result-field&gt; }}</code></p>"},{"location":"5_usage/","title":"Usage","text":"<p>This section describes advanced usage of the checker.</p>"},{"location":"5_usage/#cli","title":"CLI","text":"<p>The main checker functionality is available via CLI.</p>"},{"location":"5_usage/#checker","title":"checker","text":"<p>Manytask checker - automated tests for students' assignments.</p> <p>Usage:</p> <pre><code>checker [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>check: Check private repository: run tests, lint etc. First forces validation.</li> <li>export: Export tasks from reference to public repository.</li> <li>grade: Process the configuration file and grade the tasks.</li> <li>validate: Validate the configuration files, plugins and tasks.</li> </ul>"},{"location":"5_usage/#checker-check","title":"checker check","text":"<p>Check private repository: run tests, lint etc. First forces validation.</p> <ol> <li>Run <code>validate</code> command.</li> <li>Export tasks to temporary directory for testing.</li> <li>Run pipelines: global, tasks and (dry-run) report.</li> <li>Cleanup temporary directory.</li> </ol> <p>Usage:</p> <pre><code>checker check [OPTIONS] [ROOT] [REFERENCE_ROOT]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-t</code>, <code>--task</code> text Task name to check (multiple possible) None <code>-g</code>, <code>--group</code> text Group name to check (multiple possible) None <code>-p</code>, <code>--parallelize</code> boolean Execute parallel checking of tasks <code>True</code> <code>-n</code>, <code>--num-processes</code> integer Num of processes parallel checking <code>4</code> <code>--no-clean</code> boolean Clean or not check tmp folders <code>False</code> <code>-v</code>, <code>--verbose</code> / <code>-s</code>, <code>--silent</code> boolean Verbose tests output <code>True</code> <code>--dry-run</code> boolean Do not execute anything, only log actions <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"5_usage/#checker-export","title":"checker export","text":"<p>Export tasks from reference to public repository.</p> <p>Usage:</p> <pre><code>checker export [OPTIONS] [REFERENCE_ROOT] [EXPORT_ROOT]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--commit</code> boolean Commit and push changes to the repository <code>False</code> <code>--dry-run</code> boolean Do not execute anything, only log actions <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"5_usage/#checker-grade","title":"checker grade","text":"<p>Process the configuration file and grade the tasks.</p> <ol> <li>Detect changes to test.</li> <li>Export tasks to temporary directory for testing.</li> <li>Run pipelines: global, tasks and report.</li> <li>Cleanup temporary directory.</li> </ol> <p>Usage:</p> <pre><code>checker grade [OPTIONS] [ROOT] [REFERENCE_ROOT]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--submit-score</code> boolean Submit score to the Manytask server <code>False</code> <code>--timestamp</code> text Timestamp to use for the submission None <code>--username</code> text Username to use for the submission None <code>--branch</code> text Rewrite branch name for the submission None <code>--no-clean</code> boolean Clean or not check tmp folders <code>False</code> <code>-v</code>, <code>--verbose</code> / <code>-s</code>, <code>--silent</code> boolean Verbose tests output <code>False</code> <code>--dry-run</code> boolean Do not execute anything, only log actions <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"5_usage/#checker-validate","title":"checker validate","text":"<p>Validate the configuration files, plugins and tasks.</p> <ol> <li>Validate the configuration files content.</li> <li>Validate mentioned plugins.</li> <li>Check all tasks are valid and consistent with the manytask.</li> </ol> <p>Usage:</p> <pre><code>checker validate [OPTIONS] [ROOT]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-v</code>, <code>--verbose</code> / <code>-s</code>, <code>--silent</code> boolean Verbose output <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"5_usage/#docker","title":"Docker","text":"<p>Also, we provide a docker image with checker installed. We have tried to optimize it, but you may want to create your own image from scratch.</p> <p>The docker entrypoint is <code>checker</code> script, so you can use it as a CLI application.</p> <pre><code>docker run --rm -it manytask/checker:0.0.1-python3.8 --help\n</code></pre> <p>or you can build it from your Dockerfile</p> <pre><code>FROM manytask/checker:0.0.1-python3.8\n# ...\n</code></pre> <p>Check available versions on dockerhub.</p> <ul> <li><code>manytask/checker:main-pythonX.X</code> is main branch version of checker. It is DEVELOPMENT version and may be unstable.</li> <li><code>manytask/checker:X.X.X-pythonX.X</code> is stable version, generated from release tag.</li> </ul>"},{"location":"6_development/","title":"Developing","text":"<p>This section describes how to contribute and develop the project itself. For plugins development please refer to plugins usage and development guide.</p> <p>First of all, please refer to organization contribution guide CONTRIBUTING.md.</p>"},{"location":"6_development/#installation","title":"Installation","text":"<p>After cloning the repo, you can install it in development mode with all dev dependencies.</p> <p>Recommended way is you use virtualenv <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre></p> <p>Install lib in dev mode <pre><code>(.venv)$ pip install -U --editable .[test,docs]  # .\\[test\\] in zsh \n</code></pre></p> <p>Also, you need to install pre-commit hooks</p> <pre><code>TBA\n</code></pre>"},{"location":"6_development/#testing-and-linting","title":"Testing and linting","text":"<p>This project uses makefile to manage testing and linting. The formatting, linting and testing is mandatory for each PR.</p> <p>To apply formatting use <pre><code>(.venv)$ make format\n</code></pre></p> <p>To run linting use <pre><code>(.venv)$ make lint\n</code></pre></p> <p>To running all test or integration/unit/doctests separately use <pre><code>(.venv)$ make test\n(.venv)$ make test-integration\n(.venv)$ make test-unit\n(.venv)$ make test-doctest\n</code></pre> Note: integration tests require docker to be installed and running. TBA</p>"},{"location":"6_development/#documentation","title":"Documentation","text":"<p>This project uses <code>mkdocs</code> to generate documentation.  All documentation locating in the *.md root files and in the docs folder.  </p> <p>To run docs locally use <pre><code>(.venv)$ make docs-serve\n</code></pre> This will start local server with hot reload. </p> <p>To build docs use <pre><code>(.venv)$ make docs-build\n</code></pre> This will build docs in the <code>site</code> folder.</p>"},{"location":"6_development/#contributing","title":"Contributing","text":"<p>Really appreciate any contributions!</p> <p>Feel free to open issues and PRs. Please check on existing issues and PRs before opening new ones.</p>"},{"location":"6_development/#git-hooks","title":"Git hooks","text":"<p>This project uses pre-commit hooks to check:</p> <ul> <li><code>commit-msg</code> - check commit message format to follow conventional commits</li> </ul> <p>Please install it with (included in <code>test</code> extra) <pre><code>(.venv)$ pre-commit install --hook-type commit-msg\n</code></pre></p>"},{"location":"6_development/#ci","title":"CI","text":"<p>This project uses GitHub actions to run tests and build docs on each push and pull request.</p> <p>Your PR will not be merged if tests or docs build will fail. The following checks are mandatory:</p> <ol> <li>Testing</li> <li>Linting/typechecks/formatting</li> <li>Docs build and Docs Tests</li> <li>PR title should follow conventional commits</li> </ol>"},{"location":"7_changelog/","title":"Changelog","text":""},{"location":"7_changelog/#changelog","title":"Changelog","text":""},{"location":"7_changelog/#092-2023-12-05","title":"0.9.2 - 2023-12-05","text":"<p>Last updates before deprecation of the 0.x version</p>"},{"location":"7_changelog/#tests-and-cicd","title":"Tests and CI/CD","text":"<ul> <li>ci: enable python 12 testing by @k4black in #66</li> </ul>"},{"location":"7_changelog/#other-changes","title":"Other changes","text":"<ul> <li>ci: update ci with reusable workflows and new release flow by @k4black in #61</li> <li>ci: add dependabot updates configuration by @k4black in #56</li> <li>ci(pypi): use Trusted publishing by @k4black in #54</li> <li>ci: check PR title by @k4black in #52</li> <li>fix: export all files from root dir by @kalabukdima in #37</li> </ul>"},{"location":"7_changelog/#dependency-updates","title":"Dependency Updates","text":"<ul> <li>chore(deps-dev): bump ruff from 0.1.3 to 0.1.5 by @dependabot in #65</li> <li>chore(deps-dev): bump black from 23.10.1 to 23.11.0 by @dependabot in #64</li> <li>chore(deps-dev): update flake8 requirement from &lt;5.0.0,&gt;=4.0.0 to &gt;=4.0.0,&lt;7.0.0 by @dependabot in #60</li> <li>chore(deps-dev): bump black from 23.7.0 to 23.10.1 by @dependabot in #59</li> <li>chore(deps-dev): bump ruff from 0.0.285 to 0.1.3 by @dependabot in #58</li> <li>chore(deps): bump actions/checkout from 3 to 4 by @dependabot in #57</li> </ul> <p>Full Changelog: 0.9.1...0.9.2</p>"},{"location":"ignore_me__production/","title":"Production","text":"<p>On this page you can find documentation on how to run <code>checker</code> itself NB: Please first refer to the system setup documentation</p>"},{"location":"ignore_me__production/#installation","title":"Installation","text":"<p>In a nutshell <code>checker</code> is just a python pkg available with pip as manytask-checker. So, as it was mentioned in  system setup documentation you can install it with <pre><code>python -m pip install manytask-checker\n</code></pre> Note: check available python versions in setup configs </p> <p>You can install on your machine for developing or in docker for testing purposes.</p>"},{"location":"ignore_me__production/#pre-requirements","title":"Pre requirements","text":"<p><code>checker</code> script demands <code>.course.yml</code> and <code>.deadlines.yml</code> configs to operate;  </p> <p>It will cook up for <code>.course.yml</code> in (relative to execution folder)</p> <ol> <li><code>.course.yml</code></li> <li><code>tests/.course.yml</code></li> <li><code>tools/.course.yml</code></li> </ol> <p>After the config will be applied and <code>.deadlines.yml</code> file will be searched according to layout  (see checker/course/driver.py for layout info). </p> <p>for the format check examples folder</p> <p>Additionally, you may need the following env variables to be provided for checker  * <code>TESTER_TOKEN</code> - manytask token to push scores  * <code>GITLAB_SERVICE_TOKEN</code> - service account token to push public repo * <code>GITLAB_API_TOKEN</code> - service account api token to read merge requests  </p> <p>Reminder: YOu deferentially not want to expose these tokens for students,  so you should provide it NOT as gitlab variables, but as gitlab-runner variables</p>"},{"location":"ignore_me__production/#usage","title":"Usage","text":"<p>This pkg provides a cli application available as <code>checker</code> after installation  <pre><code>python -m checker --help\n# ot just\nchecker --help\n</code></pre></p>"},{"location":"ignore_me__production/#checker-check","title":"<code>$ checker check</code>","text":"<p>Command runs tests against ground truth solution (authors' solution) to test.. tests.  </p> <p>Able to test single task with <code>--task</code> or lecture/group with <code>--group</code> option. Can be parallelized with <code>--parallelize</code>.</p>"},{"location":"ignore_me__production/#checker-export-public","title":"<code>$ checker export-public</code>","text":"<p>Select enabled assignments (according to .deadlines.yml file) and export it from private to public repo.</p>"},{"location":"ignore_me__production/#checker-grade","title":"<code>$ checker grade</code>","text":"<p>Run students assignments testing. Should be run in gitlab-runner, as it's rely on env variables available there. </p> <ul> <li>Detect git changes between 2 last pipelines run </li> <li>Select tasks to be tested </li> <li>Run tests </li> <li>Push scores to manytask </li> </ul>"},{"location":"ignore_me__production/#checker-grade-mr","title":"<code>$ checker grade-mr</code>","text":"<p>Run grading of all merge requests in students' group (from student's repo to students' main branch) </p> <p>Run basic checks against students' MR:</p> <ul> <li>All changed files is one task</li> <li>No extra files committed</li> <li>etc</li> </ul>"},{"location":"ignore_me__production/#checker-grade-students-mrs","title":"<code>$ checker grade-students-mrs</code>","text":"<p>Run grading of all merge requests in current student's repo (from student's repo to students' main branch) </p> <p>Same checks as <code>grade-mr</code></p>"},{"location":"ignore_me__system_setup/","title":"Production setup","text":"<p>NB: First you need manytask up and running as checker is integrated with manytask only. </p> <p>Note: The following instructions assume you will use <code>checker</code>. If you are going to use custom <code>checker</code> with manytask - just read these docs for advices and approaches</p>"},{"location":"ignore_me__system_setup/#pre-requirements","title":"Pre-requirements","text":"<p>Also, please refet to the manytask setup docs -&gt; new-course/new-semester to get and set  up:</p> <ul> <li>(Self-hosted) gitlab to work with</li> <li>public repo with assignments for students </li> <li>private group for students' repo </li> <li>Virtual Machine/Server</li> <li>Running manytask instance</li> </ul>"},{"location":"ignore_me__system_setup/#layout","title":"Layout","text":""},{"location":"ignore_me__system_setup/#pre-required","title":"Pre-required","text":"<p>Assuming you already have base layout for manytask system up' see manytask setup docs -&gt; new-course/new-semester</p> <ul> <li>course group (gitlab.manytask.org), e.g. python</li> <li>this year students group (gitlab.manytask.org), e.g. python/students-fall-2022</li> <li>this year public repo (gitlab.manytask.org or gitlab.com), e.g. python/public-fall-2022</li> </ul>"},{"location":"ignore_me__system_setup/#setup-layout","title":"Setup layout","text":"<p>This script will rely on the following layouts of the course repositories</p>"},{"location":"ignore_me__system_setup/#private-repo-recommended","title":"Private-repo (recommended)","text":"<p>The following layout allows you to push assignments automatically and fielder files students will see (for example hide all docker files or configs)</p> <ul> <li><code>private</code> (gitlab.com or gitlab.manytask.org) - private repository with tasks, tests, ect - (hosted on gitlab.com (recommended) or gitlab.manytask.org) </li> <li><code>python/public-2022-fall</code> - public repository of this year with auto-exported tasks from <code>private-repo</code> (hosted on gitlab.manytask.org (recommended) or gitlab.com)</li> <li>private students' group e.g. <code>python/students-fall-2022</code></li> </ul> <p>So each student can see only <code>public-repo</code> repo and his/her own repo and can not access <code>private-repo</code></p>"},{"location":"ignore_me__system_setup/#submodule-not-recommended-but-possible","title":"Submodule (not recommended, but possible)","text":"<p>In this case auto-exporting of the tasks will not work. However, the task checking is still working.  </p> <ul> <li><code>python/public-2022-fall</code> - public repository with assignments for students   </li> <li><code>python/tests-2022-fall</code> - git <code>tests</code> submodule in <code>public-2022-fall</code>; private repository with tests and all private info </li> <li>private students' group e.g. <code>python/students-fall-2022</code></li> </ul> <p>So each student can see only <code>tasks</code> repo and his/her own repo and can not access <code>tests</code></p>"},{"location":"ignore_me__system_setup/#final-layout","title":"Final layout","text":"<p>So the recommended layout is the following </p> <p><code>gitlab.com</code> * manytask/python - course group + group runner  * manytask/python/private - private course repo (all tasks and tests)</p> <p><code>gitlab.manytask.org</code> * python - course group * python/students-fall-2022 - this year students group * python/public-fall-2022 - this year public repo (only public tasks and tests)</p>"},{"location":"ignore_me__system_setup/#service-account","title":"Service account","text":"<p>Also, you need to create service account with access to the students' repos.  </p> <p>Go to manytask.gitlab.org -&gt; [course_name] -&gt; Settings -&gt; Access Tokens Create named group token with write(!) repo and write(!) api permissions Save it and use later as <code>GITLAB_SERVICE_TOKEN</code></p> <p>It will automatically create user <code>[token_name]123_bot</code> with access to the group. The token can be used even for http access with <code>https://any_non_empty:$GITLAB_SERVICE_TOKEN@gitlab.manytask.org/path/to/the/repo.git</code> </p>"},{"location":"ignore_me__system_setup/#gitlab-runners","title":"Gitlab runners","text":"<p>You need gitlab runners to run checker script. </p> <p>This system we try to utilize shared/group runners as much as possible to decrease the number of services to up and maintain for each separate course.  </p>"},{"location":"ignore_me__system_setup/#server","title":"server","text":"<p>You need to obtain a server for your runners. The base requirements is <code>gitlab runner</code> and <code>docker</code>.</p> <p>If you create runner in separate machine, it's better to use self-hoster runner for linux If you create runner in shared machine, it's better to use self-hoster runner in docker </p> <p>Sometimes gitlab runner will leave outdated docker images, so you need to add in chrone:  <pre><code>0 3 * * * /usr/bin/bash -c 'docker system prune'\n</code></pre></p> <p>Note: if you will use shared runners for your course - just check it's available, no need to create new ones.</p>"},{"location":"ignore_me__system_setup/#gitlabcom","title":"gitlab.com","text":"<p>You need 2 runners available for your private repository: * <code>build</code> - runner for docker building * <code>private-tester</code> - to check reference-solution and test... tests</p> <ol> <li> <p>Go to the gitlab.com main group (e.g. manytask) and add runners.    If you use private runners, go to your course group (e.g. manytask/python)    Group -&gt; CI/CD settings -&gt; Runners</p> </li> <li> <p>Register runners, following register gitlab-runner instruction</p> </li> <li>Register <code>build</code> and <code>private-tester</code> runners</li> <li>It will register them in gitlab and generate <code>config.toml</code> in <code>/srv/gitlab-runner/config</code> </li> <li>Copy generated tokens from <code>config.toml</code> (you need to keep only tokens) and update <code>config.toml</code> to match examples/config.gitlab.toml </li> <li> <p>reload gitlab runner</p> </li> <li> <p>Check group to have active runners (2 in total) </p> </li> </ol>"},{"location":"ignore_me__system_setup/#gitlabmanytaskorg","title":"gitlab.manytask.org","text":"<p>Also you need runner to check students' solution </p> <p>For self-hosted gitlab instance it's even easier - we can use shared runners. If you'd like to use private runners - add it as group runners to your course group and disable shared runners.  </p> <ol> <li> <p>For shared runners go GitLab Admin Area -&gt; Overview -&gt; Runners</p> </li> <li> <p>Register runners, following register gitlab-runner instruction</p> </li> <li>Register <code>public-tester</code> runner</li> <li>It will register them in gitlab and generate <code>config.toml</code> in <code>/srv/gitlab-runner/config</code> </li> <li>Copy generated tokens from <code>config.toml</code> (you need to keep only tokens) and update <code>config.toml</code> to match examples/config.gitlab.toml </li> <li> <p>reload gitlab runner</p> </li> <li> <p>Check students group to have active runners (1 in total) </p> </li> </ol>"},{"location":"ignore_me__system_setup/#security","title":"Security","text":"<p>Note: see examples/config.gitlab.toml </p> <p>Student can change <code>.gitlab-ci.yml</code> and get all secrets exposed. So in public runner we need to compare it with original <code>.gitlab-ci.yml</code> file</p>"},{"location":"ignore_me__system_setup/#docker","title":"docker","text":"<p>Gitlab runner operates and run dockers. So you need to create docker where test will be executed </p> <p>It's convenient to have 2 dockers: </p> <ul> <li><code>base</code> - 'empty' docker with libs and apps you will use for testing (as well as <code>checker</code> pkg). Students can use it to run and test course tasks in docker</li> <li><code>testenv</code> - based on <code>base</code> docker with copied tests </li> </ul> <p>see examples/base.docker and  examples/testenv.docker</p>"},{"location":"ignore_me__system_setup/#docker-registry","title":"Docker registry","text":"<p>Currently, the main registry is docker yandex cloud registry (credentials: @slon) Be ready to set <code>DOCKER_AUTH_CONFIG</code> to gitlab-runners config (see examples/config.gitlab.toml)</p>"},{"location":"ignore_me__system_setup/#gitlab-ci","title":"gitlab-ci","text":"<p>You need to create gitlab-ci config files for gitlab to run <code>checker</code> script commands. </p> <p>We offer to create 2 separate files: * <code>.gitlab-ci.yml</code> - file with jobs to run in students repositories:     * <code>grade</code> job to general solutions testing      * <code>grade-mrs</code> job to test students' email     * <code>check</code> job to check students contributions in the repo (run updated tests against authors' solutions) * <code>.releaser-ci.yml</code> - file with jobs to run in private repo - test tasks, test tests, test course tools etc.     * <code>build</code> job to build base docker      * <code>check-tools</code> some jobs to check course tools if any     * <code>check-tasks</code> job with task testing      * <code>deploy</code> jobs to deploy testenv docker, manytask deadlines, public repo      * <code>manual</code> some jobs to run manually by tutors  </p> <p>see examples/.gitlab-ci.yml and  examples/.releaser-ci.yml</p> <p>So you need to select in private repo CI/CD Settings <code>.releaser-ci.yml</code> as ci file.</p>"},{"location":"ignore_me__system_setup/#repo-settings-and-variables","title":"Repo settings and Variables","text":"<ul> <li>In gitlab.com -&gt; [course_group]   Set variables for checker and gitlab runner to operate   </li> <li>DOCKER_AUTH_CONFIG (none),  </li> <li>TESTER_TOKEN (protected, masked),  </li> <li> <p>GITLAB_SERVICE_TOKEN (protected, masked)  </p> </li> <li> <p>In gitlab.com -&gt; [course_group] -&gt; private   Set CI/CD settings: </p> </li> <li><code>.releaser-ci.yml</code> as ci file  </li> <li>strategy - clone   </li> <li> <p>Scheduling for each day time just after the lecture (to auto publish assignments)</p> </li> <li> <p>In gitlab.manytask.org -&gt; [course_group]   Set variables for checker and gitlab runner to operate   </p> </li> <li>DOCKER_AUTH_CONFIG (none),  </li> <li>TESTER_TOKEN (masked),  </li> <li>GITLAB_SERVICE_TOKEN (masked) </li> </ul>"}]}